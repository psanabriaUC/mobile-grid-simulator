package edu.isistan.seas.proxy.bufferedproxy.genetic;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Random;

import edu.isistan.mobileGrid.jobs.Job;

/**This population generator extends MinMinIncludedPopGenerator class by adding two additional
 * restrictions to the randomly generated population. One of them refers to the quantity of
 * assigned jobs that every randomly generated individual must have. Precisely it should be 
 * equal to the quantity of assigned jobs of the MinMin individual. The other restriction
 * refers to which jobs have been assigned. Concretely, every randomly generated individual
 * must have the same jobs marked as assigned to the MinMin individual. Then, the randomness
 * has effects on the device to which jobs are assigned. 
 * This population generator is expected to create a set of individuals that are closer one
 * of each other in the solution space than the set of individuals generated by the
 * MinMinAndJobCountAssignedPopGenerator. */
public class MinMinBasedPopGenerator extends MinMinIncludedPopGenerator {
	
	@Override
	public ArrayList<Short[]> generatePopulation(ArrayList<Job> jobs, int totalIndividuals, int individualChromosomes, int chromoMaxValue) {
		
		ArrayList<Short[]> population = new ArrayList<Short[]>();
		Short[] minMinIndividual = getMinMinIndividual(jobs);
		totalIndividuals--;
		population.add(minMinIndividual);
		population.addAll(getMinMinBasedIndividuals(minMinIndividual,totalIndividuals, individualChromosomes, chromoMaxValue));
		return population;
	}
	
	private Collection<Short[]> getMinMinBasedIndividuals(Short[] minMinIndividual, int totalIndividuals, int individualChromosomes, int chromoMaxValue){
		
		Random rand = new Random();		
		ArrayList<Short[]> ret = new ArrayList<Short[]>();
		
		for (int ind=0; ind < totalIndividuals; ind++){
			
			Short[] minBasedInd = new Short[individualChromosomes];
			Arrays.fill(minBasedInd, (short)-1);
			for (int chromo=0; chromo < individualChromosomes; chromo++)
				if (minMinIndividual[chromo] != -1)
					minBasedInd[chromo] = (short)rand.nextInt(chromoMaxValue);
			
			ret.add(minBasedInd);			
		}
		
		return ret;
	}

}
